#include <iostream>
#include <cmath>
//если сделать n слишком маленьким, то у нас будет маленький диапазон значение, после чего образуются коллизии  
int real_string_hash(std::string word, int p, int n);

int main(int argc, char *argv[]) {
	std::string word;
	int p = 0;
	int n = 0;
	std::cout << "Введите p: ";
	std::cin >> p;
	std::cout << "Введите n: ";
	std::cin >> n;
	do {
		std::cout << "Введите строку: ";
		std::cin >> word;
		std::cout << "Наивный хэш строки " << word << " = "<< real_string_hash( word , p, n )<< std::endl;
	} while (word != "exit");
		return 0;
}

int real_string_hash(std::string word, int p, int n){
	int res = 0;
	for(int i = 0; i < word.size() ;i++){
		res += int(word[i])* pow(p,i);
	}
	return res % n;
}



//Вам нужно реализовать функцию, которая рассчитывает хэш для строки с помощью серьёзного алгоритма. Функция будет называться real_string_hash.
//
//Функция должна принимать на вход строку, а возвращать хэш этой функции — целое число. Настоящий алгоритм вычисления хэша для строки выглядит так: берётся простое число p и число n — модуль. Простое число — число, у которого нет целых делителей, кроме единицы и самого числа. Затем код каждого символа строки умножается на p в степени индекса этого символа, полученные числа складываются. В конце берётся остаток от деления получившейся суммы на число n — это и будет хэш.
//
//После написания функции её необходимо протестировать. Для этого организуйте работу с пользователем: попросите его задать числа p и n. Они будут использоваться в работе программы. Просите его ввести строку и в ответ выводите на консоль значение хэша этой строки, посчитанного по реализованному вами алгоритму. Делайте это до тех пор, пока пользователь не введёт exit. Когда пользователь введёт exit, посчитайте хэш этой строки, выведите его на консоль и завершите работу программы.
//
//Поэкспериментируйте с разными значениями p и n. Посмотрите, что происходит, если n сделать достаточно маленьким, меньше 5.
//
//Следите за размером используемых переменных. Размеры
//
//Также ответ можно сохранить в массив по цифре в ячейке. Для хранения промежуточных значений лучше использовать uint64_t или long long